# 230412

## í•„í„°ê¸°ë°˜ ì¡°í–¥ê° ì œì–´

### ì°¨ì„ ìœ„ì¹˜ ì •ë³´ë¥¼ ì´ìš©í•œ ì¡°í–¥ê° ì œì–´ ë°©ë²•

**ìë™ì°¨ ìš´ì „ : ì¡°í–¥ ë° ì†ë„ ì œì–´**

- ì¡°í–¥ê° ì œì–´
    - ì§ì„  : ì •ë©´ , ê³¡ì„  : íœ˜ì–´ì§„ ë°©í–¥
- ì†ë„ì œì–´
    - ì§ì„ : ë¹ ë¥´ê²Œ , ê³¡ì„  : ì†ë„ ì œì–´

**ì°¨ì„ ì˜ ìœ„ì¹˜ì •ë³´ë¥¼ ì´ìš©í•˜ì—¬ ì£¼í–‰í•  ìˆ˜ ìˆê²Œë”!**

- ì¹´ë©”ë¼ë¥¼ í†µí•œ ì°¨ì„  ì¸ì‹ì˜ í•œê³„ì ë“¤ :  ë¹› , ê·¸ëŠ˜, ë°˜ì‚¬ê´‘, ì¥ì• ë¬¼ ë•Œë¬¸ì— ì°¨ì„ ì´ ê°€ë¦¬ëŠ” ê²½ìš°
- ì˜¤ë¥˜ê°€ ìƒê¸°ë©´ ë³€ë™ì´ ì‹¬í•´ì§ â†’ **ì „ì²´ ê´‘ì´ ë°ì•„ì§€ê±°ë‚˜ ì–´ë‘ì›Œì§€ëŠ” êµ¬ê°„ì—ì„œ thresholdë¥¼ ìë™ìœ¼ë¡œ ì„¤ì •í•  ìˆ˜ ìˆëŠ” ë°©ë²•ì€?**
- ì¡°í–¥ê°ì´ ìê¾¸ ë³€í•˜ë©´ â†’ í•¸ë“¤ì´ ì‹¬í•˜ê²Œ ì›€ì§ì„ , ì°¨ì„ ì´íƒˆ ìœ„í—˜ì´ ìˆë‹¤!
- **ë¶€ë“œëŸ¬ìš´ í•¸ë“¤ë§ì´ í•„ìš”! (ì¡°í–¥ê° ê°’ì— ëŒ€í•œ í•„í„°ë§)**

### ì¡°í–¥ê°ì— ëŒ€í•œ í•„í„°ë§

ì¹´ë©”ë¼ â†’ ì°¨ì„ ì°¾ê¸° â†’ ì¡°í–¥ê° ê³„ì‚° â†’ í•„í„° â†’ ëª¨í„°ì œì–´ 

### í•„í„°ë¥¼ ì´ìš©í•œ ë¶€ë“œëŸ¬ìš´ í•¸ë“¤ë§ ë°©ë²•

### ê°„ë‹¨í•œ í•„í„°ë“¤

- í‰ê·  í•„í„° Average filter
- ì´ë™í‰ê·  í•„í„° Moving average filter (ë„ˆë¬´ ì˜›ë‚  ë°ì´í„°ëŠ” ì‚¬ìš©í•˜ì§€ ì•ŠìŒ, ìµœê·¼ Nê°œë§Œ ì´ìš©)
- ê°€ì¤‘ ì´ë™í‰ê·  í•„í„° : ê°€ì¥ ìµœì‹ ë°ì´í„°ì— ê°€ì¤‘ì¹˜ë¥¼ ë‘ 
- ì €ì£¼íŒŒ í†µê³¼ í•„í„° Low-pass filter : ì§€ìˆ˜ê°€ì¤‘ ì´ë™í‰ê·  í•„í„°

### í•¸ë“¤ë§ì—ëŠ” ì–´ë–¤ í•„í„°ê°€ ì ë‹¹í• ê¹Œ?

- ì´ë™í‰ê·  (ê³¼ê±° ê°’ ë²„ë¦¬ê¸°)
- ê°€ì¤‘ ì´ë™í‰ê·  í•„í„° (ìµœì‹ ê°’ ì¤‘ìš”)
- ì°¨ì„ ìœ„ì¹˜ or ì¡°í–¥ê° ë°ì´í„°ì— ì ìš©
    
    ![Untitled](img2/Untitled.png)
    

- í•„í„° ì½”ë“œ ì ìš©
    
    ```python
    class MovingAverage:
    	# init : ma = MovingAverage(50) # 50ê°œ ë°ì´í„°ë§Œ í•­ìƒ ì²˜ë¦¬í•˜ê² ë‹¤
    	def __init__(self, n):
    		self.samples = n
    		self.data = []
    		self.weights = list(range(1, n + 1))
    	
    	# sample ì¶”ê°€í•˜ê¸°
    	def add_sampele(self, new_sample):
    		if len(self.data) < self.samples:
    			self.data.append(new_sample) # ìƒˆë¡œìš´ ìƒ˜í”Œì„ ë§¨ ë’¤ì— ì¶”ê°€í•˜ê¸°
    		else:
    			self.data = self.data[1:] + [new_sample] # ê½‰ ì°¼ìœ¼ë©´ ì œì¼ ì˜¤ë˜ëœ ìƒ˜í”Œ ë²„ë¦¬ê¸°
    		print("samples: %s" % self.data)
    
    	# ì´ë™í‰ê·  í•„í„°	
    	def get_mm(self):
    		return float(sum(self.data)) / len(self.data) 
    
    	# ê°€ì¤‘ì´ë™í‰ê·  í•„í„°
    	def get_wm(self):
    		s = 0
    		for i, x in enumerate(self.data):
    			s += x* self.weights[i]
    		return float(x) / sum(self.weigths[:len(self.data)]) 
    ```
    
    ```python
    def start():
    	
    	global pub, image, cap, video_mode, Width, Height
    	
    	# ê°€ì¤‘ì´ë™í‰ê· ì„ êµ¬í•˜ê¸° ìœ„í•œ ìƒ˜í”Œ 50ê°œ
    	mm1 = MovingAverage(50)
    
    	rospy.init_node('auto_drive')
    	pub = rospy.Publisher('xycar_motor', xycar_motor, queue_size = 1)
    	image_sub = rospy.Subscriber("/usb_cam/image_raw", Image, img_callback)
    	rospy.sleep(2)
    
    	while True:
    		while not image.size == (640*480*3): # ì¹´ë©”ë¼ ì˜ìƒ ì´ë¯¸ì§€ë¥¼ í•œì¥ì”© ì²˜ë¦¬
    			continue
    
    		lpos, rpos = process_image(image) # ì™¼ìª½ì°¨ì„ ê³¼ ì˜¤ë¥¸ìª½ ì°¨ì„ ì˜ ìœ„ì¹˜ ì°¾ê¸°
    		center = (lpos + rpos) / 2 # ì°¨ì„ ì˜ ì¤‘ì ê³¼ í™”ë©´ ì¤‘ì•™ê³¼ì˜ ì°¨ì´ê°’ì„ ì¡°í–¥ê°ìœ¼ë¡œ ê³„ì‚°
    		angle = (center - width / 2)
    	
    		mm1.add_sample(angle)
    		wmm_angle = mm1.get_wmm() # 50ê°œì˜ ìƒ˜í”Œì—ì„œ ê°€ì¤‘ì´ë™í‰ê· ê°’ êµ¬í•˜ê¸°
    		
    		drive(wmm_angle, 30) # êµ¬í•´ì§„ ì¡°í–¥ê°(ê°€ì¤‘ì´ë™í‰ê· ê°’)ì„ ëª¨í„°ì œì–´ ë…¸ë“œë¡œ ë³´ë‚´ê¸°
    ```
    

## PID ê¸°ë°˜ ì¡°í–¥ê° ì œì–´

â†’ í•„í„°ëŠ” ê·¸ëŸ¬ë©´ í¸ì°¨ë¥¼ ì¼ì •í•˜ê²Œ ë½‘ì„ ìˆ˜ ìˆëŠ” ê²ƒì´ê³  ì´ ì´í›„ì— PID ì œì–´ë¥¼ í†µí•´ ë¶€ë“œëŸ½ê²Œ í•˜ëŠ” ê²ƒì¸ê°€?

### ì œì–´ê°œìš”

- Control ê¸°ë²•ì˜ ì¢…ë¥˜
    - Open Loop Control (ê²°ê³¼ì— ëŒ€í•œ í™•ì¸ê³¼ì •ì´ ì—†ìŒ: Input â†’ control â†’ output)
    - Closed Loop Control (feedbackì´ ìˆëŠ” ì‹œìŠ¤í…œ : Measuring element ê³¼ì •ì´ ìˆìŒ)
- Closed loop control
    - ì„¼ì„œ ë“±ì„ í†µí•´ ë°ì´í„°ë¥¼ ìˆ˜ì§‘í•˜ê³  , ìˆ˜ì§‘ëœ ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë°˜ë³µì ì¸ í”¼ë“œë°±ìœ¼ë¡œ ì œì–´í•˜ëŠ” ê¸°ë²•
    - ëŒ€í‘œì ì¸ closed loop control ê¸°ë²• â†’ PID control

![Untitled](img2/Untitled%201.png)

### í”¼ë“œë°± ì œì–´ë€?

- Process ë¥¼ ê±°ì³ì„œ ë‚˜ì˜¨ Outputì´ Inputì— ì˜í–¥ì„ ë¯¸ì¹˜ëŠ” Loop
- ì œì–´ ê°’ì´ 2ê°œ ë°–ì— ì—†ê¸° ë–„ë¬¸ì— ì¼ì •ê°’ ì£¼ë³€ì„ ë§´ë„ëŠ” ì§„ë™ì˜ í˜„ìƒì´ ì¼ì–´ë‚˜ê²Œ ë¨

![Untitled](img2/Untitled%202.png)

- On-Offë¥¼ ë°˜ë³µ : ì¶œë ¥ê°’ì˜ ë³€í™”ê°€ ë§¤ìš° í¼
- ì‹œê°„ì´ ì§€ë‚˜ë„ ëª©í‘œê°’ê³¼ì˜ ì˜¤ì°¨ëŠ” ì¤„ì–´ë“¤ì§€ ì•ŠìŒ
    
    ![Untitled](img2/Untitled%203.png)
    

### PID ì œì–´ê¸°

- ë¹„ë¡€ : Propotional
- ì ë¶„ : Integral
- ë¯¸ë¶„ : Differential
- ì œì–´ ëŒ€ìƒì˜ ëª©í‘œê°’(desired value)ê³¼ ì¶œë ¥ê°’(output)ê³¼ì˜ ì°¨ì´ë¡œ ì œì–´ê°’ì„ ê³„ì‚°
    
    ![Untitled](img2/Untitled%204.png)
    

### PID ì œì–´ ê°œìš”

- ì£¼ìš”ìš©ì–´ ê°œë…
    - ì˜¤ë²„ìŠˆíŠ¸ : ìµœì¢… ì •ìƒìƒíƒœ ê°’ì„ ë„˜ì–´ì„œëŠ” ìƒìŠ¹ì˜¤ì°¨
    - í”¼í¬ ì‹œê°„ : ê°€ì¥ í° overshootê°€ ë°œìƒí–ˆì„ ë•Œ ì‹œê°„
    - ìƒìŠ¹ì‹œê°„ : outputì˜ 0.1 ~ 0.9 ê¹Œì§€ ì´ë¥¼ ë•Œ ê±¸ë¦¬ëŠ” ì‹œê°„
    - ì •ì°©ì‹œê°„ : ìµœì¢… ì •ìƒìƒíƒœì— ë„ë‹¬í•˜ëŠ” ì‹œê°„
        
        ![Untitled](img2/Untitled%205.png)
        
- PID ì œì–´ ìˆ˜ì‹
    
    ![Untitled](img2/Untitled%206.png)
    

### P ì œì–´ (ë¹„ë¡€ : Propotional)

- í”¼ë“œë°± ì œì–´ì‹ í˜¸ê°€ ì˜¤ì°¨ì— ë¹„ë¡€í•˜ê²Œ ë§Œë“œëŠ” ë¹„ë¡€ ì œì–´ê¸°
    
    ![Untitled](img2/Untitled%207.png)
    

![Untitled](img2/Untitled%208.png)

- ex ) PID ì œì–´ê¸°ê°€ ì—†ì„ ë•Œ : ëª©í‘œê°’ì— ë„ë‹¬í•˜ì§€ ì•Šê³  ì§„ë™ì´ ì‹¬í•¨
- ex 1 ) PID ì œì–´ê¸°ë¥¼ ë„£ì„ ê²½ìš°
    - P gain ê°’ì´ ì‘ì„ ë•Œ (P-gain = 1, I-gain = 1, D-gain =1)
    - ëª©í‘œê°’ì— ë„ë‹¬ì€ í•˜ì§€ë§Œ ì˜¤ë²„ìŠˆíŠ¸ ë°œìƒ
    - ë°˜ì‘ì†ë„ ëŠë¦¼
- ex 2 ) P gain ê°’ì´ í´ ë•Œ
    - ìƒìŠ¹ì‹œê°„ì´ ì¤„ì–´ë“¬, ë°˜ì‘ì†ë„ê°€ ë¹ ë¥´ë‹¤
    - ì •ìƒìƒíƒœ ì˜¤ì°¨(steedy-state error) ë°œìƒ
        
        > ì¡°ì‘ëŸ‰ì´ ë„ˆë¬´ ì‘ì•„ ì¸¡ì •ì˜¤ì°¨ ë²”ìœ„ì— ì†í•˜ì—¬ ì„¸ë°€í•œ ì œì–´ê°€ í˜ë“¤ì–´ì§ˆ ìˆ˜ë„ ìˆë‹¤ëŠ” ì˜ë¯¸ì´ë‹¤. ê²°êµ­ ëª©í‘œì¹˜ì— ë§¤ìš° ê°€ê¹Œìš´ ìƒíƒœë¡œ ì•ˆì •ë˜ì–´ ë²„ë¦¬ëŠ” í˜„ìƒì´ ì¼ì–´ë‚˜ê³ , ì´ë•Œ ëª©í‘œì¹˜ì™€ì˜ í¸ì°¨ê°€ ì”ë¥˜í¸ì°¨ê°€ ëœë‹¤. ì¦‰, **ì„¤ì •ê°’ì— ë§¤ìš° ê·¼í•œ ìƒíƒœì—ì„œ ì•ˆì •í™”ë˜ì–´ë²„ë ¤ ì¸¡ì •ê°’ê³¼ ì„¤ì •ê°’ì´ ê°™ì•„ì§ˆ ìˆ˜ê°€ ì—†ì–´ì§„ë‹¤**
        > 
        

### I ì œì–´ ( ì ë¶„ : Integral )

- ì˜¤ì°¨ì˜ ì”ë¥˜ë¥¼ ì œê±°í•  ìˆ˜ ìˆìŒ

![Untitled](img2/Untitled%209.png)

![Untitled](img2/Untitled%2010.png)

- ex ) I gainì´ ì¦ê°€ (P-gain = 5, I-gain=2, D-gain=1)
    - ë°˜ì‘ì†ë„ê°€ ë¹¨ë¼ì§€ê³  ì •ìƒìƒíƒœ ì˜¤ì°¨ê°€ ì—†ì–´ì§
    - but ì˜¤ë²„ìŠˆíŠ¸ê°€ í¬ê²Œ ë°œìƒ

### D ì œì–´ (ë¯¸ë¶„ : Differential)

- ë¯¸ë¶„ì„ ì´ìš©í•˜ì—¬ ì§„ë™ì„ ì¤„ì´ê³  ì•ˆì •ì„±ì„ í–¥ìƒí•˜ëŠ” ì œì–´ ë°©ë²•
    - ê¸‰ê²©í•œ ì¶œë ¥ê°’ì˜ ë³€ë™ì´ ë°œìƒí•  ë•Œ ê¸‰ê²©í•˜ê²Œ ë³€í•˜ì§€ ì•Šë„ë¡ í•¨
    - ì˜¤ì°¨ê°€ ìƒìˆ˜ì¼ ê²½ìš° D ì œì–´ê¸°ì˜ ì¶œë ¥ì€ 0ì´ ë˜ì–´ ì •ìƒìƒíƒœ ì˜¤ì°¨ë¥¼ ì¤„ì¼ ìˆ˜ ì—†ìŒ

![Untitled](img2/Untitled%2011.png)

![Untitled](img2/Untitled%2012.png)

![Untitled](img2/Untitled%2013.png)

![Untitled](img2/Untitled%2014.png)

![Untitled](img2/Untitled%2015.png)

![Untitled](img2/Untitled%2016.png)

![Untitled](img2/Untitled%2017.png)

![Untitled](img2/Untitled%2018.png)

### ê°€ì¥ ì´ìƒì ì¸ ì œì–´ê²°ê³¼

- ë¹ ë¥¸ ì‘ë‹µì†ë„
- ì˜¤ë²„ìŠˆíŠ¸ê°€ ë°œìƒí•˜ì§€ ì•ŠìŒ
- ì •ìƒìƒíƒœ ì˜¤ì°¨ê°€ ë°œìƒí•˜ì§€ ì•ŠìŒ
- gain ê°’ì‚¬ì´ì˜ trad-offë¥¼ ì ì ˆíˆ íƒ€í˜‘ ë³´ê¸°
- ì£¼ë¡œ 5% ì´ë‚´ì˜ ì˜¤ë²„ìŠˆíŠ¸, 0.2ì´ˆ ì´ë‚´ì˜ ì •ì°©ì‹œê°„ì„ ì„¤ì •í•¨ â†’ ì‹œìŠ¤í…œì— ë”°ë¼ ë‹¬ë¼ì ¸ì•¼í•¨!

### PID ì œì–´ë¥¼ ì¡°í–¥ê° ì œì–´ì— ì ìš©í•˜ê¸°

- ëª©í‘œ ê²½ë¡œë¥¼ ê·¸ëŒ€ë¡œ ë”°ë¼ ê°€ê²Œë”!
- CTE(Cross Track Error)ê°’ì„ 0ìœ¼ë¡œ ë§Œë“¤ê¸° - íŠ¸ë™ì´ ëª©í‘œ ê¶¤ì 

![P D ê°€ í•©ì³ì ¸ì„œ ìµœì¢…ì ìœ¼ë¡œ ë¹¨ê°„ìƒ‰ìœ¼ë¡œ ì´ë™](img2/Untitled%2019.png)

P D ê°€ í•©ì³ì ¸ì„œ ìµœì¢…ì ìœ¼ë¡œ ë¹¨ê°„ìƒ‰ìœ¼ë¡œ ì´ë™

![Untitled](img2/Untitled%2020.png)

![ì ë¶„ì œì–´ê¹Œì§€ í•©ì¹œë‹¤ë©´](img2/Untitled%2021.png)

ì ë¶„ì œì–´ê¹Œì§€ í•©ì¹œë‹¤ë©´

![Untitled](img2/Untitled%2022.png)

### ìì´ì¹´ ì¡°í–¥ê° ê³„ì‚°ë²•

![Untitled](img2/Untitled%2023.png)

![Untitled](img2/Untitled%2024.png)

![Untitled](img2/Untitled%2025.png)

![Untitled](img2/Untitled%2026.png)

```python
# PID class
class PID():
	
	def __init__(self, kp, ki, kd):
		
		self.Kp = kp
		self.Ki = ki
		self.Kd = kd
		self.p_error = 0.0
		self.i_error = 0.0
		self.d_error = 0.0

	def pid_control(self, cte):
		
		self.d_error = cte - self.p_error # Dê°’ì€ cte(t) - ì´ì „ p ê°’ ì°¨ì´ : ë³€í™”ëŸ‰
		self.p_error = cte # P ê°’ì€ CTE ê°’ì„ ê·¸ëŒ€ë¡œ ì ìš©
		self.i_error += cte # IëŠ” CTEëˆ„ì  ê³„ì† ë”í•¨ : ëˆ„ì 

		retrun self.Kp*self.p_error + self.Ki*self.i_error + self.Kd*self.d_error

# start driving

def start():
	global pub, image, cap, Width, Height

	rospy.init_node('auto_drive')
	pub = rospy.Publisher('xycar_motor', xycar_motor, queue_size=1)

	image_sub = rospy.Subscriber("/usb_cam/image_raw", Image, img_callback)
	print " --------------xycar A2 v1.0------------"
	
	while True:
		while not image.size == (640*480*4):
			continue
		lpos, rpos = process_image(image)
		center = (lpos + rpos) / 2
		error = (center - width/2)
		angle = (pid.pid_control(error))
		drive(angle, 30)	
		
```

![Untitled](img2/Untitled%2027.png)

![Untitled](img2/Untitled%2028.png)

![Untitled](img2/Untitled%2029.png)

![Untitled](img2/Untitled%2030.png)

![Untitled](img2/Untitled%2031.png)

| ì†ë„ | P / I / D | ê²°ê³¼ |
| --- | --- | --- |
| ë‚®ì€ ì†ë„ | 0.45 / 0.0007 / 0.25 | ì°¨ ì•ˆì •ì  |
| ë†’ì€ ì†ë„ | 0.55/x/0.4 | ì‚´ì§ í”ë“¤ë¦¼ |

---

**[ğŸ†™ ëª©ì°¨ë¡œ ëŒì•„ê°€ê¸° ğŸ”—](https://www.notion.so/230412-2bf9c779056b4647aa537c37871cf462)** 

---

# âš’ï¸ week ì‹¤ìŠµ

## [ê³¼ì œ 1] í—ˆí”„ë³€í™˜ ê¸°ë°˜ ì°¨ì„ ì¸ì‹ ì£¼í–‰

- ì‹¤ì œ íŠ¸ë™ì—ì„œ ì°¨ì„ ì„ ë²—ì–´ë‚˜ì§€ ì•Šê³  ì£¼í–‰
    - ì¹´ë©”ë¼ë¡œ ì´¬ì˜í•œ ì°¨ëŸ‰ ì „ë°© ë„ë¡œ ì˜ìƒì—ì„œ OpenCVë¥¼ ì´ìš©í•˜ì—¬ ì°¨ì„ ì„ ì°¾ê³  ì–‘ìª½ ì°¨ì„ ì˜ ìœ„ì¹˜ë¥¼ ë”°ì ¸ì„œ í•¸ë“¤ì„ ì–¼ë§ˆë‚˜ êº¾ì„ì§€ ì¡°í–¥ê°ì„ ê²°ì •
- ì°¨ì„ ì¸ì‹ ì£¼í–‰ì„ ìœ„í•´ í•„ìš”í•œ ê²ƒë“¤
    - ì¹´ë©”ë¼ ì…ë ¥ ë°ì´í„° í”„ë ˆì„ ì·¨ë“í•˜ê¸° (ì¹´ë©”ë¼ í† í”½ êµ¬ë…)
    - ì–»ì–´ë‚¸ ì˜ìƒ ë°ì´í„° ì²˜ë¦¬
        - BGR to Gray Scale
        - ì™¸ê³½ì„  ì¶”ì¶œ : Canny
        - ê´€ì‹¬ì˜ì—­ ROI ì˜ë¼ë‚´ê¸°
    - ì°¨ì„ ê²€ì¶œ : í—ˆí”„ë³€í™˜ìœ¼ë¡œ ì§ì„ ì°¾ê¸°
        - ì–‘ìª½ ì°¨ì„ ì„ ë‚˜íƒ€ë‚´ëŠ” í‰ê·  ì§ì„  êµ¬í•˜ê¸°
        - ìˆ˜í‰ì„ ì„ ê¸‹ê³  ì–‘ìª½ ì§ì„ ê³¼ êµì  ì¢Œí‘œ êµ¬í•˜ê¸°
    - ì°¨ì„ ìœ„ì¹˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì¡°í–¥ê° ê²°ì •
        - ì°¨ì„ ì˜ ì¤‘ì•™ì„ ì°¨ëŸ‰ì´ ë‹¬ë¦¬ë„ë¡
    - ê²°ì •í•œ ì¡°í–¥ê°ì— ë”°ë¼ ì¡°í–¥ ëª¨í„°ë¥¼ ì œì–´
        - ëª¨í„°ì œì–´ í† í”½ ë°œí–‰
    
    ![Untitled](img2/Untitled%2032.png)
    
    â†’ ë¹¨ê°„ìƒ‰ ì‚¬ê°í˜•ê³¼ ì´ˆë¡ìƒ‰ ì‚¬ê°í˜•ì´ ì¼ì¹˜í•˜ë„ë¡ ì¡°í–¥ê°ì„ ì„¤ì •í•´ì•¼í•¨
    

### í—ˆí”„ë³€í™˜ì„ ì´ìš©í•œ ì°¨ì„  ì°¾ê¸°

- Image Read : ì¹´ë©”ë¼ ì˜ìƒì‹ í˜¸ ì´ë¯¸ì§€ ì½ê¸°
- GrayScale : í‘ë°± ì´ë¯¸ì§€ë¡œ ë³€í™˜
- Gaussian Blur : ë…¸ì´ì¦ˆ ì œê±°
- Canny : Edge ê²€ì¶œ
- ROI : ê´€ì‹¬ì˜ì—­ ì˜ë¼ë‚´ê¸°
- HoughLinesP : ì„ ë¶„ê²€ì¶œ
- ì°¨ì„  ìœ„ì¹˜ íŒŒì•…
- í•¸ë“¤êº¾ê¸°

![Untitled](img2/Untitled%2033.png)

![hough_drive.launch](img2/Untitled%2034.png)

hough_drive.launch

![hough_drive.py](img2/Untitled%2035.png)

hough_drive.py

- ì‹¤í–‰ê²°ê³¼ ë¯¸ë¦¬ ë³´ê¸°
    - ì¹´ë©”ë¼ ì˜ìƒë°ì´í„° ìˆ˜ì§‘
    - ì¢Œìš° ì°¨ì„  ìœ„ì™€ ë‘ ì  ì¤‘ê°„ ìœ„ì¹˜ì— ë…¹ìƒ‰ ì‚¬ê°í˜•
    - í™”ë©´ì˜ ì¤‘ì•™ì ì— ë¹¨ê°„ìƒ‰
    - ì°¨ëŸ‰ì´ ë²—ì–´ë‚˜ì§€ ì•Šê³  ì£¼í–‰

![Untitled](img2/Untitled%2036.png)

![Untitled](img2/Untitled%2037.png)

## [ê³¼ì œ 2] ìŠ¬ë¼ì´ë”© ìœˆë„ìš° ê¸°ë°˜ ì°¨ì„ ì¸ì‹ ì£¼í–‰

- ì‹¤ì œ íŠ¸ë™ì—ì„œ ì°¨ì„ ì„ ë²—ì–´ë‚˜ì§€ ì•Šê³  ì£¼í–‰

![Untitled](img2/Untitled%2038.png)

![Untitled](img2/Untitled%2039.png)

![Untitled](img2/Untitled%2040.png)

![Untitled](img2/Untitled%2041.png)

![Untitled](img2/Untitled%2042.png)

![Untitled](img2/Untitled%2043.png)

## [ê³¼ì œ 3]  í•„í„°ì ìš©

[ê³¼ì œ #1] ì¡°í–¥ê° ë°ì´í„°ê°€ ì•„ë‹Œ ì°¨ì„ ìœ„ì¹˜ ë°ì´í„°ì— ì ìš©í•´ë³´ì

```python
def start():
	
	global pub, image, cap, video_mode, Width, Height
	
	# ê°€ì¤‘ì´ë™í‰ê· ì„ êµ¬í•˜ê¸° ìœ„í•œ ìƒ˜í”Œ 50ê°œ
	ml1 = MovingAverage(50)
	mr1 = MovingAverage(50)

	rospy.init_node('auto_drive')
	pub = rospy.Publisher('xycar_motor', xycar_motor, queue_size = 1)
	image_sub = rospy.Subscriber("/usb_cam/image_raw", Image, img_callback)
	rospy.sleep(2)

	while True:
		while not image.size == (640*480*3): # ì¹´ë©”ë¼ ì˜ìƒ ì´ë¯¸ì§€ë¥¼ í•œì¥ì”© ì²˜ë¦¬
			continue

		lpos, rpos = process_image(image) # ì™¼ìª½ì°¨ì„ ê³¼ ì˜¤ë¥¸ìª½ ì°¨ì„ ì˜ ìœ„ì¹˜ ì°¾ê¸°
		ml1.add_sample(lpos)
		mr1.add_sample(rpos)
		ml_pos , mr_pos = ml1.get_wmm(), mr1.get_wmm()

		center = (ml_pos + mr_pos) / 2 # ì°¨ì„ ì˜ ì¤‘ì ê³¼ í™”ë©´ ì¤‘ì•™ê³¼ì˜ ì°¨ì´ê°’ì„ ì¡°í–¥ê°ìœ¼ë¡œ ê³„ì‚°
		angle = (center - width / 2)
	
	
		drive(angle , 30) # êµ¬í•´ì§„ ì¡°í–¥ê°(ê°€ì¤‘ì´ë™í‰ê· ê°’)ì„ ëª¨í„°ì œì–´ ë…¸ë“œë¡œ ë³´ë‚´ê¸°
```

[ê³¼ì œ #2] ì°¨ëŸ‰ì˜ ì†ë„ê°€ ëŠë¦´ë•Œì™€ ë¹ ë¥¼ë•Œ, ì–´ë–¤ í•„í„°ê°€ íš¨ê³¼ì ì¸ì§€ ì•Œì•„ë³´ì (ì €ì†ì£¼í–‰ / ê³ ì†ì£¼í–‰)

## [ê³¼ì œ 4] PID ì œì–´

ê³¼ì œ 1 : ìì´ì¹´ D ëª¨ë¸ì˜ PID gain ê°’ ì°¾ê¸°

ê³¼ì œ 2 : PID gain ê°’ ì°¾ê¸° - ì†ë„!ì™€ ê´€ë ¨í•´ì„œ ë¶€ë“œëŸ¬ìš´ ì œì–´í•˜ê¸°

- https://www.slideshare.net/dheeruee/pid-control-45432861

## ê³¼ì œ tip

![Untitled](img2/Untitled%2044.png)

â†’ ê°ë„ê°€ ì¼ì •í•  ìˆ˜ ìˆë„ë¡ ì¡°ì •

â†’ íŠ¸ë™ ì°¨ì„ ì´ ë³´ì´ì§€ ì•ŠëŠ” ê²½ìš° (ë°˜ì‚¬ê´‘, ì°¨ì„ ì´ ê¸‰í•˜ê²Œ íœ˜ì–´ì§€ëŠ” ê²½ìš° , ë‹¤ë¥¸ ì„  ì¸ì§€) 

![Untitled](img2/Untitled%2045.png)

â†’ ì™¼ìª½ì°¨ì„ ì¸ì§€ ì˜¤ë¥¸ìª½ ì°¨ì„ ì¸ì§€ êµ¬ë¶„ í•˜ëŠ” ë°©ë²• : ROI ì• ë’¤ìª½ ì´ë‚˜ ì°¨ì„ ì´ íœ˜ì–´ì§€ëŠ” ê°ë„ ìª½ì„ ì°¾ì•„ì„œ êµ¬ë¶„í•˜ê¸° ? â‡’ ì¼ì • ê±°ë¦¬ë¥¼ ë›°ì–´ì„œ ì£¼í–‰í•˜ê¸°

### ì¡°í–¥ ë° ì†ë„ ì œì–´

- ì¡°í–¥ê° ì œì–´
    - ì§ì„  ì°¨ë¡œ : ì •ë©´
    - ê³¡ì„ ì°¨ë¡œ : ì°¨ë¡œê°€ íœ˜ì–´ì§„ ë°©í–¥ìœ¼ë¡œ ì¡°í–¥
- ì†ë„ ì œì–´
    - ì§ì„  ë¹ ë¥´ê²Œ!
    - ê³¡ì„ ì€ ì²œì²œíˆ!

![Untitled](img2/Untitled%2046.png)

# TIL

- hough ì‹¤ìŠµ 1ì°¨ì•ˆ
    
    ```python
    #!/usr/bin/env python
    # -*- coding: utf-8 -*-
    
    import rospy, rospkg
    import numpy as np
    import cv2, random, math
    from cv_bridge import CvBridge
    from xycar_motor.msg import xycar_motor
    from sensor_msgs.msg import Image
    from collections import deque
    
    import sys
    import os
    import signal
    
    #pid ì œì–´
    class PidControl:
       
        def __init__(self, kp, ki, kd):
            self.kp = kp
            self.ki = ki
            self.kd = kd
            self.p_error = 0
            self.i_error = 0
            self.d_error = 0
    
        def pid_control(self, cte):
            self.d_error = cte-self.p_error
            self.p_error = cte
            if cte:
                self.i_error+=cte
            else:
                self.i_error = 0
            return self.kp*self.p_error+self.ki*self.i_error+self.kd*self.d_error
    
    class MovingAverage:
        def __init__(self, n):
            self.samples = n
            self.data = deque()
            self.weights = list(range(1, n+1))
    
        def add_sample(self, new_sample):
            if self.data and self.data[-1]*new_sample < 0:
                self.data = deque()
                self.data.append(new_sample)
            elif len(self.data) < self.samples:
                self.data.append(new_sample)
            else:
                self.data.popleft()
                self.data.append(new_sample)
    
        def get_mm(self):
            return float(sum(self.data)) / len(self.data)
    
        def get_wmm(self):
            total = 0
            length = 0
            for i, data in enumerate(self.data):
                total += (i+1) * data
                length += (i+1)
            vector = np.vectorize(np.float)
            total = vector(total)
            return total / length
    
        def get_emm(self):
            total = 0
            length = 0
            for i, data in enumerate(self.data):
                total += ((i+1)**2) * data
                length += (i+1)**2
            vector = np.vectorize(np.float)
            total = vector(total)
            return total / length
    
    def signal_handler(sig, frame):
        os.system('killall -9 python rosout')
        sys.exit(0)
    
    signal.signal(signal.SIGINT, signal_handler)
    
    image = np.empty(shape=[0])
    bridge = CvBridge()
    pub = None
    Width = 640
    Height = 480
    Offset = 350#370
    Gap = 40#60 #40
    
    def img_callback(data):
        global image    
        image = bridge.imgmsg_to_cv2(data, "bgr8")
    
    # publish xycar_motor msg
    def drive(Angle, Speed): 
        global pub
    
        msg = xycar_motor()
        msg.angle = Angle
        msg.speed = Speed
    
        pub.publish(msg)
    
    # draw lines
    def draw_lines(img, lines):
        global Offset
        for line in lines:
            x1, y1, x2, y2 = line[0]
            color = (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))
            img = cv2.line(img, (x1, y1+Offset), (x2, y2+Offset), color, 2)
        return img
    
    # draw rectangle
    def draw_rectangle(img, lpos, rpos, offset=0):
        center = (lpos + rpos) / 2
    
        cv2.rectangle(img, (lpos - 5, 15 + offset),
                           (lpos + 5, 25 + offset),
                           (0, 255, 0), 2)
        cv2.rectangle(img, (rpos - 5, 15 + offset),
                           (rpos + 5, 25 + offset),
                           (0, 255, 0), 2)
        cv2.rectangle(img, (center-5, 15 + offset),
                           (center+5, 25 + offset),
                           (0, 255, 0), 2)    
        cv2.rectangle(img, (315, 15 + offset),
                           (325, 25 + offset),
                           (0, 0, 255), 2)
        return img
    
    # left lines, right lines
    def divide_left_right(lines):
        global Width
        print("check", lines)
        low_slope_threshold = 0
        high_slope_threshold = 10
    
        # calculate slope & filtering with threshold
        slopes = []
        new_lines = []
    
        for line in lines:
            x1, y1, x2, y2 = line[0]
    
            if x2 - x1 == 0:
                slope = 0
            else:
                slope = float(y2-y1) / float(x2-x1)
            
            if abs(slope) > low_slope_threshold and abs(slope) < high_slope_threshold:
                slopes.append(slope)
                new_lines.append(line[0])
    
        # divide lines left to right
        left_lines = []
        right_lines = []
    
        for j in range(len(slopes)):
            Line = new_lines[j]
            slope = slopes[j]
    
            x1, y1, x2, y2 = Line
    
            if (slope < 0) and (x2 < Width/2 - 90):
                left_lines.append([Line.tolist()])
            elif (slope > 0) and (x1 > Width/2 + 90):
                right_lines.append([Line.tolist()])
    
        return left_lines, right_lines
    
    # get average m, b of lines
    def get_line_params(lines):
        # sum of x, y, m
        x_sum = 0.0
        y_sum = 0.0
        m_sum = 0.0
    
        size = len(lines)
        if size == 0:
            return 0, 0
    
        for line in lines:
            x1, y1, x2, y2 = line[0]
    
            x_sum += x1 + x2
            y_sum += y1 + y2
            m_sum += float(y2 - y1) / float(x2 - x1)
    
        x_avg = x_sum / (size * 2)
        y_avg = y_sum / (size * 2)
        m = m_sum / size
        b = y_avg - m * x_avg
    
        return m, b
    
    # get lpos, rpos
    def get_line_pos(img, lines, left=False, right=False):
        global Width, Height
        global Offset, Gap
    
        m, b = get_line_params(lines)
    
        if m == 0 and b == 0:
            if left:
                pos = 0
            if right:
                pos = Width
        else:
            y = Gap / 2
            pos = (y - b) / m
    
            b += Offset
            x1 = (Height - b) / float(m)
            x2 = ((Height/2) - b) / float(m)
    
            cv2.line(img, (int(x1), Height), (int(x2), (Height/2)), (255, 0,0), 3)
    
        return img, int(pos)
    
    # show image and return lpos, rpos
    def process_image(frame):
        global Width
        global Offset, Gap
    
        # gray
        gray = cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)
    
        # blur
        kernel_size = 5
        blur_gray = cv2.GaussianBlur(gray,(kernel_size, kernel_size), 0)
    
        # canny edge
        low_threshold = 60
        high_threshold = 70
        edge_img = cv2.Canny(np.uint8(blur_gray), low_threshold, high_threshold)
        cv2.imshow('canny_image', edge_img)
    
        # HoughLinesP
        roi = edge_img[Offset : Offset+Gap, 0 : Width]
        all_lines = cv2.HoughLinesP(roi,1,math.pi/180,30,30,10)
        cv2.imshow('roi', roi)
    
        # divide left, right lines
        if all_lines is None:
            return 0, 640
        left_lines, right_lines = divide_left_right(all_lines)
    
        # get center of lines
        frame, lpos = get_line_pos(frame, left_lines, left=True)
        frame, rpos = get_line_pos(frame, right_lines, right=True)
        # print(lpos)
        # draw lines
        frame = draw_lines(frame, left_lines)
        frame = draw_lines(frame, right_lines)
        frame = cv2.line(frame, (230, 235), (410, 235), (255,255,255), 2)
                                     
        # draw rectangle
        frame = draw_rectangle(frame, lpos, rpos, offset=Offset)
        #roi2 = cv2.cvtColor(roi, cv2.COLOR_GRAY2BGR)
        #roi2 = draw_rectangle(roi2, lpos, rpos)
    
        # show image
        cv2.imshow('calibration', frame)
    
        return lpos, rpos
    def draw_steer(image, steer_angle):
        global Width, Height, arrow_pic
    
        # read of steer_arrow
        arrow_pic = cv2.imread('steer_arrow.png', cv2.INREAD_COLOR)
    
        # to calcurate
        origin_Height = arrow_pic.shape[0]
        origin_Width = arrow_pic.shape[1]
        steer_wheel_center = origin_Height * 0.74
        arrow_Height = Height / 2
        arrow_Width = (arrow_Height * 462) / 728
    
        # rotate steer img by using steer angle
        matrix = cv2.getRotatedMatrix2D((origin_Width / 2, steer_wheel_center), (steer_angle) * 2.5, 0.7)
    
        # fit img 
        arrow_pic = cv2.warpAffine(arrow_pic, matrix, (origin_Width + 60, origin_Height))
        arrow_pic = cv2.resize(arrow_pic, dsize = (arrow_Width, arrow_Height), interpolation = cv2.INTER_AREA)
    
        # full image + steer angle
        gray_arrow = cv2.cvtColor(arrow_pic, cv2.COLOR_BGR2GRAY)
        _, mask = cv2.threshold(gray_arrow, 1, 255, cv2.THRESH_BINARY_INV)
    
        arrow_roi = image[arrow_Height : Height, 
                          (Width / 2 - arrow_Width / 2) : (Width / 2 + arrow_Width / 2)]
        arrow_roi = cv2.add(arrow_pic, arrow_roi, mask = mask)
    
        res = cv2.add(arrow_roi, arrow_pic)
    
        image[(Height - arrow_Height) : Height,
              (Width / 2 - arrow_Width / 2) : (Width / 2 + arrow_Width / 2)] = res
        
        cv2.imshow('steer', image)
    # def draw_angle(draw_image, steer_angle):
    #     cv2.putText(draw_image, str(steer_angle), (50,50), cv2.FONT_ITALIC, 1, (255,0,0), 2)
    
    #     cv2.imshow('angle', draw_image)
    def start():
        global pub
        global image
        global cap
        global Width, Height
    
        rospy.init_node('auto_drive')
        pub = rospy.Publisher('xycar_motor', xycar_motor, queue_size=1)
    
        image_sub = rospy.Subscriber("/usb_cam/image_raw", Image, img_callback)
        rospy.sleep(5)
    
        angle = 2.5
        angle_temp = 2.5 
        speed = 5
        angle_list = []
    
        mm = MovingAverage(40)
        ml = MovingAverage(10)
        mr = MovingAverage(10)
        pid = PidControl(0.56, 0.0007, 0.2)
    
        while True:
            while not image.size == (640*480*3):
                continue
    
            lpos, rpos = process_image(image)
            print(lpos, rpos)
            ml.add_sample(lpos)
            mr.add_sample(rpos)
    
            lpos = ml.get_wmm()
            rpos = mr.get_wmm()
    
            center = (lpos + rpos) / 2
            error = -(Width/2 - center)
    
            angle = pid.pid_control(error)
    
            mm.add_sample(angle)
            mean_angle = mm.get_wmm()
    
            if lpos==0 and rpos==640: # can't recognize lanes
                angle_temp = angle
                drive(angle_temp, 5)
                continue
                
    
            steer_angle = mean_angle * 0.4
            # draw_angle(image, mean_angle)
            if abs(mean_angle) >= 50:
                drive(50, 5)#10)
                print("1")
                print(mean_angle)
    
                # Offset = 360
            elif 30 < abs(mean_angle) < 50:
                if mean_angle < 0:
                    drive(-20, 7 )#12)
                else:
                    drive(20, 7 )#12)
    
                print("2")
                print(mean_angle)
                # Offset = 365
            else:
                drive(0, 8 )#15)
                # Offset = 370
                print("3")
                print(mean_angle)
    
            if cv2.waitKey(1) & 0xFF == ord('q'):
                break
    
        rospy.spin()
    
    if __name__ == '__main__':
    
        start()
    ```
